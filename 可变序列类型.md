1. 可变序列（支持原位改变，比如列表）

1\) 列表list：包含任意类型对象的有序集合

2\) 列表的存储：

前面我们介绍了整型和字符串的存储机制，那列表的存储机制又不一样了，如下：

例子：

&gt;&gt;&gt; x = \[1, 2, 3\]

这个过程是怎么发生的呢？

前面讲到内存有2个部分，一个部分是变量表，一个部分是内存区域。那对于列表来说，首先内存区域先开辟出3个空间，分别分配1、2和3，三个值，

这里注意是三个值，并不是1个。

然后变量表里有1个x，列表存储与普通变量存储不同的地方体现在：在内存中有第三个部分：引用，在这个引用里有三个下标0、1、2，这三个下标分别指向对应的实际的值。然后变量x是指向的引用区域里的引用。

在引用区域里存放的是实际对象的引用，并非实际对象。



python列表支持原位改变，也就是：

&gt;&gt;&gt; x\[0\] = ’tom’

&gt;&gt;&gt; x

\[’tom’, 2, 3\]

这个过程，在我们内存中是怎么发生的呢？



那我们继续想，如果此时有一个数值等于2的变量，他是不是和列表下标为1的指向同一个对象呢？我们可以验证一下：

&gt;&gt;&gt; z = 2

&gt;&gt;&gt; x\[1\] == z

True

&gt;&gt;&gt; x\[1\] is z

True

这说明变量z和列表下标为1的指向了同一内存中的对象。前面我们也讲过0-255之间的都有共享引用的特性，也就是说无论把对象2放在列表里还是放在变量里都是指向同一个对象。



3\) 列表支持的常用的操作：

a. 列表的声明：

&gt;&gt;&gt; x = \[1, 2, 3\]

&gt;&gt;&gt; x

\[1, 2, 3\]

&gt;&gt;&gt; name = list\(‘优品课程’\)

\[‘优’,’品’,’课’,’程’\]

&gt;&gt;&gt; range\(5\)

range\(0, 5\)

&gt;&gt;&gt; list\(range\(5\)\)

\[0, 1, 2, 3, 4\]

b. 列表的特殊操作：

排序：列表.sort\(\)

&gt;&gt;&gt; scores = \[88, 66, 99\]

&gt;&gt;&gt; scores.sort\(\)

&gt;&gt;&gt; scores

\[66, 88, 99\]

&gt;&gt;&gt; scores.reverse\(\)

&gt;&gt;&gt; scores

\[99, 88, 66\]

数值型排序可能比较简单，但有时候也涉及到字母。

&gt;&gt;&gt; people = \['Tom', 'Jerry', 'Peter'\]

&gt;&gt;&gt; people.sort\(\)

&gt;&gt;&gt; people

\['Jerry', 'Peter', 'Tom'\]

&gt;&gt;&gt; people.sort\(key=lambda x:x\[-1\]\) \#按照元素中最后一个字母排序

&gt;&gt;&gt; people

\['Tom', 'Peter', 'Jerry’\]



&gt;&gt;&gt; scores.sort\(reverse=True\) \#反向排序

&gt;&gt;&gt; scores

\[99, 88, 66\]



&gt;&gt;&gt; scores

\[99, 88, 66\]

&gt;&gt;&gt; sorted\(scores\) \#全局函数，直接使用，反向排序

\[66, 88, 99\]

&gt;&gt;&gt; sorted\(people, key=lambda n:n\[1\]\) \#假设每个名字都是n，n\[1\]代表名字的第二个元素排序

\['Peter', 'Jerry', 'Tom’\]



4）可变序列的通用操作：

a. 通过索引改变某个位置的值

b. 改变某个范围的值：s\[start:end\] = t,这里注意t也必须是一个可迭代的对象，简单理解为t也是一个序列，但是序列的个数不一定要和等号左边序列个数一致。

&gt;&gt;&gt; s = list\(range\(1, 11\)\)

&gt;&gt;&gt; s

\[1, 2, 3, 4, 5, 6, 7, 8, 9, 10\]

&gt;&gt;&gt; s\[:3\] = list\(range\(2,20,2\)\)

&gt;&gt;&gt; s

\[2, 4, 6, 8, 10, 12, 14, 16, 18, 4, 5, 6, 7, 8, 9, 10\]



&gt;&gt;&gt; s\[:5\] = \[999\]

&gt;&gt;&gt; s

\[999, 12, 14, 16, 18, 4, 5, 6, 7, 8, 9, 10\]

注意，这样操作会将原列表元素个数降低，因为你只给了一个元素。这个元素会提前等号左边的所有元素。



&gt;&gt;&gt; l = list\(range\(1,11\)\)

&gt;&gt;&gt; l

\[1, 2, 3, 4, 5, 6, 7, 8, 9, 10\]

&gt;&gt;&gt; l\[::2\] = \[99\]

Traceback \(most recent call last\):

  File "&lt;pyshell\#37&gt;", line 1, in &lt;module&gt;

    l\[::2\] = \[99\]

ValueError: attempt to assign sequence of size 1 to extended slice of size 5

注意：如果使用步长的话，要给与等号左边相同元素数目的可迭代对象

&gt;&gt;&gt; l\[::2\] = \[99, 99, 99, 99, 99\]

&gt;&gt;&gt; l

\[99, 2, 99, 4, 99, 6, 99, 8, 99, 10\]

c. 删除序列元素

&gt;&gt;&gt; l

\[99, 2, 99, 4, 99, 6, 99, 8, 99, 10\]

&gt;&gt;&gt; del l\[0\]

&gt;&gt;&gt; l

\[2, 99, 4, 99, 6, 99, 8, 99, 10\]

&gt;&gt;&gt; x = del l\[0\]

SyntaxError: invalid syntax

&gt;&gt;&gt; del l\[::3\]

&gt;&gt;&gt; l

\[99, 4, 6, 99, 99, 10\]

&gt;&gt;&gt; l\[:3\] = \[\]

&gt;&gt;&gt; l

\[99, 99, 10\]

上面的例子可总结为：给原序列赋值一个空序列也相当于删除对应元素的效果。

d. 序列.remove\(元素值\)：这种方法适用于不关心元素序列，仅仅知道元素值；当序列中包含多个相同元素的时候，只会删除第一个元素。

e. 序列.clear\(\): 清空序列

f. 扩展元素：1）序列.append\(obj\):追加一个元素，不管obj是序列还是什么，都会当成一个元素在尾部追加；

2）序列.extend\(obj\)，追加的是多个元素，扩展序列，见下面例子：

&gt;&gt;&gt; x = list\(range\(2,6\)\)

&gt;&gt;&gt; x

\[2, 3, 4, 5\]

&gt;&gt;&gt; x.append\(8\)

&gt;&gt;&gt; x

\[2, 3, 4, 5, 8\]

&gt;&gt;&gt; x.append\(\[9,9\]\)

&gt;&gt;&gt; x

\[2, 3, 4, 5, 8, \[9, 9\]\]

&gt;&gt;&gt; x.extend\(\[10,10\]\)

&gt;&gt;&gt; x

\[2, 3, 4, 5, 8, \[9, 9\], 10, 10\]

g. 在序列的具体位置插入元素 序列.insert\(位置，新元素\)

i. 序列.pop\(元素位置\)，弹出并且删除某一个元素。元素位置默认最后一个

&gt;&gt;&gt; x

\[2, 3, 4, 5, 8, \[9, 9\], 10, 10\]

&gt;&gt;&gt; x.pop\(\)

10

&gt;&gt;&gt; x

\[2, 3, 4, 5, 8, \[9, 9\], 10\]

&gt;&gt;&gt; x.pop\(1\)

3

&gt;&gt;&gt; x

\[2, 4, 5, 8, \[9, 9\], 10\]

m. 序列.reverse\(\) : 不返回任何值，只是影响原序列，元素顺序倒转

n. 复制序列：

&gt;&gt;&gt; l = list\(range\(11\)\)

&gt;&gt;&gt; l

\[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\]

&gt;&gt;&gt; x = l

&gt;&gt;&gt; x\[0\] = 99

&gt;&gt;&gt; x

\[99, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\]

&gt;&gt;&gt; l

\[99, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\]

通过上面例子可以看出，若通过直接=赋值的方式复制一个相同的序列的时候，其实两个序列共享了引用，也就意味着其中一个被改变的时候，另一个也在被改变。



但是这可能不是你想要的结果，如果只复制序列内容，而不是共享引用呢？

第一种方法：

&gt;&gt;&gt; x = list\(range\(4\)\)

&gt;&gt;&gt; x

\[0, 1, 2, 3\]

&gt;&gt;&gt; y = x\[:\] \#赋值的是x的值

&gt;&gt;&gt; y

\[0, 1, 2, 3\]

&gt;&gt;&gt; y\[0\] = 9

&gt;&gt;&gt; y

\[9, 1, 2, 3\]

&gt;&gt;&gt; x

\[0, 1, 2, 3\]

第二种方法：copy\(\)方法

&gt;&gt;&gt; x

\[0, 1, 2, 3\]

&gt;&gt;&gt; y = x.copy\(\)

&gt;&gt;&gt; y

\[0, 1, 2, 3\]

&gt;&gt;&gt; y\[2\] = 99

&gt;&gt;&gt; y

\[0, 1, 99, 3\]

&gt;&gt;&gt; x

\[0, 1, 2, 3\]



