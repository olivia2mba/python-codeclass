一、变量

1. Python的程序概念层级：表达式--语句--函数--类---模块--包---.py程序

2. 表达式：创建和处理对象

3. python程序可能保存在硬盘上，但python对象保存在内存中（程序运行中的任何对象）

4. 为什么要创建变量？

当我们需要反复引用内存中的某些值的时候，给值起一个名字即变量，可以方便操作。

5.变量命名规则补充：1）变量名之间不能有空格 2）避免和python里的关键字/函数名一样 3）区别大小写，并且只有在类命名的时候首字母才大写，

其他情况都用小写

6. 在python里，变量的创建是第一次赋值时生成，也就是说必须给变量赋值。没有赋值的变量会出错。

1. python有强类型并且是动态类型的特点，动态类型和静态类型的区别：

1）静态类型：在声明变量的时候，就已经确定好这个变量的数据类型，在后面的赋值中不能赋值不同类型的数据。并且可不给初始值。

2）动态类型：python中变量本身没有类型约束，其类型是根据赋值给变量的字面值类型决定的，可跟着赋值的字面值类型动态改变。

也就是说python的对象是自带类型说明的，这个类型也决定了能对这个变量进行什么样的操作。8.

1. 变量的存储：

1）我们可以将内存分成两部分：第一部分是变量表，第二部分是内存存储区；

2）实例 x = 20

x = 20的过程是：首先，在内存存储区域开辟一块内存空间，然后分配了一个值是20；然后将x这个变量名称指向刚才内存区域20这个对象。

相当于在内存存储区域里先有20这个对象，然后变量表里x再指向这个对象。这个指向我们也可以称为引用。

3）实例：

&gt;&gt;&gt; x = 20

&gt;&gt;&gt; x = "Jerry"

由于python变量动态类型的特点，这个过程不需要进行强制转换即可顺利完成。

那这个过程怎么解释呢？

a. x = 20的过程无需解释，如上第2）例子。

![](/assets/1)

b. 接着，在内存存储区域会开辟一块内存空间，然后分配了一个string类型的值Jerry；然后变量x重新指向（引用）新对象Jerry。

c. 那原来的对象20如果没有变量引用的话会怎么处理呢？

在python内部有一个垃圾回收机制，python会侦测到如果没有引用的变量在特定的时间会被回收，释放所占用的资源。那它是如何知道这个对象有没有被引用呢？

在内部有一个引用计数器，通过判断引用计数器是不是0来判断有没有变量引用它。

4）共享引用：

实例：

&gt;&gt;&gt; x = "tom"

&gt;&gt;&gt; y = "tom"

那这里的变量x和变量y是否指向同一个变量呢？有一个方法可以判断不同变量是否指向同一个变量。

a. 有一个函数id\(参数\)，可以判断某对象在内存中存储的地址。

&gt;&gt;&gt; id\("tom"\)

57406208

&gt;&gt;&gt; id\(y\)

57406208

&gt;&gt;&gt; id\(x\)

57406208

说明变量x和y都是指向了内存中的同一个地址，这个地址里存储了一个对象tom。这种情况就是共享引用（即多个变量引用同一个对象）

b. 判断两个变量是否相等有2个层面的意思：一个层面是字面值是否相等，另一个层面的意思判断是否指向同一个对象。

判断字面值相等的方法：

&gt;&gt;&gt; a = 50

&gt;&gt;&gt; b = 50

&gt;&gt;&gt; a == b

True

判断是否指向同一个内存地址，除了上面通过id\(\)函数判断之外，还有一个简便的方法：

&gt;&gt;&gt; a is b

True

c. 那可以问：如果两个变量的字面值相同，内存地址就一定相同吗？答案是：不一定

&gt;&gt;&gt; mike = 8000

&gt;&gt;&gt; peter = 8000

&gt;&gt;&gt; mike == peter

True

&gt;&gt;&gt; mike is peter

False

说明mike和peter并不是指向同一个变量，也就是并非共享引用。

&gt;&gt;&gt; url = "[http://www.codeclass.com](http://www.codeclass.com)"

&gt;&gt;&gt; link = "[http://www.codeclass.com](http://www.codeclass.com)"

&gt;&gt;&gt; url == link

True

&gt;&gt;&gt; url is link

False

规律：0-255之间的值都缓存起来了，也就是不管你用不用，python已经把这部分值已经开辟好了。

为啥是0-255？因为这之间只是2的八次方，8个比特位，一个字符的大小。比较小，相当于字符a在硬盘中占的空间。

也就是所在这个范围内，当你引用其中的对象时，python已经不会另开辟空间，是共享引用的过程。为了提高效率。

对于字符串也一样，python缓存了一些比较短的字符串。

